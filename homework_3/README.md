#### [1. ДЗ - 1: LINK HERE](./task1/arrayFunctions.js)

Написати модуль, який експортує аналоги методів для роботи з масивами:
+ forEach
+ filter
+ map
+ slice
+ reduce
+ splice 

**Приклад:**


```javascript
let array = [1, 2, 3, 4, 5, 6];
forEach (array, item => console.log (item));
let greaterThan4 = filter (array, item => item> 4);
let sqare = map (array, item => item * item);
```
Опис того, як працюють ці методи, є на Mozilla Developer Network і в безкоштовних відеоуроку LoftBlog / LoftSchool.
     
Реалізація функції splice є завданням із зірочкою *.
Її виконання не обов'язково, але бажано.

**Увага:**
 в даному завданні заборонено використовувати вбудовані методи для роботи з масивами! Дозволено використовувати стандартні
оператори for / for-in / while / if (і т.д.) і властивість length


#### [2. ДЗ - 2 LINK HERE](./task2/)

Як відомо, в js не існує способу перевірити ідентичність об'єктів.
Написавши 'objA === objB' ми отримаємо true тільки в тому випадку, якщо objA і objB вказують на один і той же об'єкт.

Завдання: написати функцію deepEqual, яка приймає в якості параметрів два аргуманта - два об'єкти.

+ Якщо обидві змінні вказують на один і той же об'єкт, значить обидва об'єкти ідентичні.

+ Якщо обидва об'єкти мають однакові властивості і їх значення, значить обидва об'єкти ідентичні.

Подивіться на приклади того, як повинна працювати функція deepEqual:
```javascript
var objA = {
    prop1: 'value1',
    prop2: 'value2',
    prop3: 'value3',
    prop4: {
        subProp1: 'sub value1',
        subProp2: {
            subSubProp1: 'sub sub value1',
            subSubProp2: [1, 2, {prop2: 1, prop: 2}, 4, 5]
        }
    },
    prop5 1000,
    prop6: new Date (2016, 2, 10)
};

var objB = {
    prop5 1000,
    prop3: 'value3',
    prop1: 'value1',
    prop2: 'value2',
    prop6: new Date ( '2016/03/10'),
    prop4: {
        subProp2: {
            subSubProp1: 'sub sub value1',
            subSubProp2: [1, 2, {prop2: 1, prop: 2}, 4, 5]
        },
        subProp1: 'sub value1'
    }
    console.log (deepEqual (objA, objB)); // об'єкти ідентичні, поверне true
};
```

        
Не дивлячись на те, що властивості в objB перемішані (послідовність свойст в objB отічается від послідовності властивостей в objA), функція все одно поверне true, так як кількість властивостей, з імена і значення збігаються в обох об'єктів.
Так само зверніть всніманіе, що deepEqual повинна працювати рекурсивно.

Це означає, що якщо значенням якогось властивості об'єкта є масив або об'єкт, то почати звіряти і їх у обох об'єктів.

+ Якщо одним з елементів звіряти масиву, є інший масив або об'єкт, то їх теж треба звірити рекурсивно.

При звірці об'єктів - послідовність властивостей не важлива, але при звірці масивів, вашна послідовність елементів, тобто масиви: [1,2,3,4] і [2,1,3,4] нерівні, так як , хоча і мають однакові значення, відрізняються в послідовності цих значень.

Так само зверніть увагу, що дати теж повинні порівнюватися коректно, не дивлячись на відмінності в способах створення.

+ Заборонено використовувати сторонні бібліотеки типу jQuery, underscore та інші.